3 data types:
1-local var.
2-instance var.
3-static var.
===========================================
Compile time: is the time at which the source code is converted into an executable code.
Run time: is the time at which the executable code starts running.
===========================================
Reference types:
1-primitive for simple objects
2-reference for complex objects(new Something)
===========================================
*Association:1-class A keeps a reference of class B.
             2-permanent relationship.

*Dependancy:1-class A doesnt keep a reference of class B.
            2-temporary relationship.
===========================================
*inner classes types:
1-Anonymous inner class
2-Nester inner class.
3-Local inner class.(inside a method class)**11
4-Static inner class.
------
-class is the main container of methods.
------
final:
-*If you make any class as final, you cannot extend it(NO INHERITANCE).
-*blank final variables can only be initialized inside a constructor.
-*A static final variable that is not initialized at the time of declaration is known as static blank final variable,
it can be initialized only in static block.
-constructors can never be final(can't be inherited).
------
-*abstract class can take anything(i.e.:constructor,instance field/method,abstract method) except an object.
-*abstract class can only be declared,not instantiated[i.e.:Parent something = new Child();]
-method is part of the class.
-methods can be pre-defined or user defined.
===========================================
*Order of execution:
1-Initializing superclass static variable superInt
2-Executing superclass static block
3-Initializing subclass static variable subInt
4-Executing subclass static block
5-Initialzing superclass instance variable superInstanceInt
6-Running superclass object initialization block
7-Running superclass constructor
8-Running subclass object initialization block
9-Initialzing subclass instance variable subInstanceInt
10-Running subclass constructor
===========================================
-static block gets executed once automatically once the class is used.
-non static block gets executed every time we create an object of the main class
-constructors are used to create instances of the class(must have same class name)
-"main" method gets executed at the end.
-you can't call a non static method from a static method(like "main")
-must set setter/getter for defined fields
===========================================
-calendar function
-difference in callability with static/non static methods(liked video)
-when use static and non static?
=lma yb2a elblock msh hyt3'yr feh 7aga wla hytlob 7aga mn eluser yb2a static.
otherwise dynamic.
===========================================
OOP:
1-Abstraction
2-Encapsulation
3-Inheritance
4-polymorphism
===========================================
Interfaces:
-*in java8,you can use default and static methods inside an interface without breaking code,in addition to adding new functionalities
to your client projects.
-*all fields are naturally public static final.
-*all methods are naturally public abstract.
-unlike classes,interfaces can inherit multiple parents.
-interfaces dont have method implementation inside them,only method declaration.
-we can use constructor,setter,or method injections to inject methods to classes
 while using interfaces.
-interface segregation is for assigning each interface with a particular capability,and making interfaces more light weight.
-instead of using static methods inside interfaces(to be reused by any class that implements that interface),use an abstract class
that implements the interface,and put the code inside it and then extend that class in your coding class.(IMPORTANT)
*-Inheritance vs Interface: if both have the same implemented method and a subclass inherits and implements them,
the method will be implemented from the inheritance(closer relationship than interface).
----------
"For both interfaces implemented,with same method":
*-I1(Default method),I2(Default method)-->error
*-I1(Default method),I2(Unimplemented method)-->error
*-I1(Default method),I2(Static method)-->no error

===========================================
Exceptions:(8,9,10*mohem fash5,11,12)
1-checked:the compiler highlights it with red and tells u to handle it
2-unchecked(runtime):programming error that occurs after running the code(like nullpointer exception)
3-errors:exceptions outside our application(not enough memory or stack overflow error)

Heirarchy:(Throwable)-->1-Exception-->Runtime Exception(Unchecked),-->otherwise checked
                     -->2-Error
API: Application Programming Interface.
===========================================
Collections:(4,5)
-for arraylists mostly
-Collections.addall(List,1,2,3,4,5);
-Collections.findAny(1);
-Collections.clear();



===========================================
functional interfaces:
1-consumer:consumes a parameter and returns nothing{ accept() }
2-supplier:returns a value and consumes nothing{ get() }
3-function:represents a function that maps a value to another(mapping/hashmap)
4-predicate(true or false):helps test if a unit satisfies certain criteria

*lambda expressions are associated with functional interfaces because they are used to represent single abstract(Standalone)methods.
===========================================
stream operations:
1-intermediate operations(filter,map):perform operations and return new streams,but nothing gets done.
2-terminal operations(forEach,count,collect):consumes the new operated stream and executing the final form.

-in streams,.collect() method lets u collect a stream data into a data structure.
-in streams,.map() method changes the type of a stream(from "Movie object" stream to String/int/etc... stream)
-in streams,.flatMap(Collection::stream) converts a list into a stream.
*-in streams, Stream<primitive> list,the count() method counts all elements as 1 element,
Stream<reference> counts each element inside list.Use primitive streams instead(IntStream<Primitive> list).


===========================================
to get maximum value in arraylist :
Collections.max(list)
advanced forEach loop:
for( var item:list)
sout(item)->prints all items in list
sout(list)->prints entire list
inside an array
Collections tutorial very important
===========================================
Concurrency:(dealing with threads)
1-Thread.start() : starts a thread
2-Thread.sleep(millis:5000) : pauses a thread for 5 sec
3-Thread.interrupt():interrupts a thread
4-Thread.join():makes current thread wait for the completion of another thread and then runs itself.

Strats for thread safety:
1-confinement: not sharing data across threads(simplest)
2-immutability: sharing unchangeable objects
3-Synchronization: prevent multiple threads from accessing same object concurrently(using LOCKS,on critical sections)
(deadlock problem:2 threads waiting for each other indefinitely,AVOID USING SYNCHRONIZATION )
4-Atomic objects: using non breaking down objects
5-Partitioning: divide data into sections to be accessed concurrently for each thread to access a section.(Using collection classes)
===========================================
executive framework(Executor-check docs): doesn't help with concurrency problems but helps with thread manipulation
asynchronous programming: using all threads in a non-blocking way to get the maximum use from them and not make any thread wait.
thenRunAsync(): runs the current operation on another thread
thenRun(): runs the current operation on the main thread
===========================================
from labs:
1-abstract methods(have no body)
2-for(Animal animal in Animals)
if(animal instanceOf Cat/Dog).....instanceOf(to get if an object is a reference of a certain class)

===========================================
Singleton: Singleton is a creational design pattern that lets you ensure that a class *has only one instance*, while providing a global access point to this instance.
The Singleton pattern solves two problems at the same time:
Ensure that a class has just a single instance.
Provide a global access point to that instance.

enums:
*enum classes cannot inherit any other class because they implicitly inherit the Enum class,but they can implement interfaces.

More notes:
*in streams/lambdas,using the new keyword is associated with any class to instantiate it as a method reference.
Example:[stream.filter(classname::new).collect(Collectors.tolist)].

*Calendar:dob.get(Calendar.YEAR)+"/"+dob.get(Calendar.MONTH)+"/"+dob.get(Calendar.DAY_OF_MONTH)->toString to type year,month,day.
*whenever you override equals() method,you have to override hashcode() method too in order to get same index in memory.

-this() keyword:
=refers to a previously mentioned instance field or local variable or class constructor.
1-this() --->refers to class constructor.
2*****-this(Args) calls parametrized constructor from inside default constructor.
===>REAL USAGE of this keyword,chaining of constructors,if you have multiple constructors,
 you can just call another constructor without repeating the declaration of parameters using this(Args)inside 2nd constructor,and so on.
3-this.something refers to instance field OR local variable.
4-this.method() refers to a previously declared method.
5-method(this):can be passed as a dummy arg in case if the arg was meant to be of reference type,not primitive.


